# electron-window-redux

Use redux in electron, and control the action flow between main and browser process.

This project origins from [electron-redux](https://github.com/hardchor/electron-redux).
Before using this package, reading the original project is highly recommended.

## Features

- A `action` fired by main-process can be consumed by one or several specific renderer-processes.

- The `state` of each process are individual. Main-process holds some universal state.

- `windowManager` in main-process will use `name` and `windowID` property to identify windows with the same `name` or identify exact one window with `windowID`.


## Install

```
npm install --save electron-window-redux
```

`electron-window-redux` comes as redux middleware that is really easy to apply:

```javascript
// store.js
import {
  forwardToRenderer
} from 'electron-window-redux';
import { createStore, applyMiddleware } from 'redux';
import rootReducer from './reducers';

// make sure store is singleton in the whole main-process.
const store = createStore(rootReducer, applyMiddleware(
  forwardToRenderer
));


export default store;

//==========

// main.js
import { app } from 'electron';
import { replayActionMain } from 'electron-window-redux';
import mainStore from './main/store';

app.on('ready', () => {
  // responce to actions from renderer-processes
  replayActionMain(mainStore);
}
```

```javascript
// in the renderer store
import {
  forwardToMain,
  replayActionRenderer,
} from 'electron-redux';

const rootReducer = combineReducers(reducers);

const store = createStore(
  rootReducer,
  initialState,
  applyMiddleware(
    forwardToMain, // IMPORTANT! This goes first
    ...otherMiddleware,
  )
);

replayActionRenderer(store);
```


## Actions

Actions fired **HAVE TO** be [FSA](https://github.com/acdlite/flux-standard-action#example)-compliant, i.e. have a `type` and `payload` property. Any actions not passing this test will be ignored and simply passed through to the next middleware.

> NB: `redux-thunk` is not FSA-compliant out of the box, but can still produce compatible actions once the async action fires.

### Local actions(renderer process)

By default, all actions are being broadcast from the renderer processes to the main processes. However, some state should only live in the renderer (e.g. `isPanelOpen`). `electron-redux` introduces the concept of action scopes.

To stop an action from propagating from renderer to main store, simply set the scope to `local`:

```javascript
function myLocalActionCreator() {
  return {
    type: 'MY_ACTION',
    payload: 123,
    meta: {
      scope: 'local',
    },
  };
}
```

Lifecycle of action with `local` scope:

`Renderer`: `store.dispatch`-> `Action` -> `store.reducers`

### specified actions(renderer process & main process)

`electron-window-redux` use `name` and `windowID` to identify browserWindow.
(reminding that this windowID is generated by `Symbol` not the internal one created by `electron`).

eg: Set scope to `dialog` the action will be sent to browserWindows with name `dialog`, no matter the action is fired from
main store or renderer store.

actions scope with `windowID` go the same way, except the only browserWindow with the same windowID will receive the action.
